"""Story structure models."""
from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field


class ChapterOutline(BaseModel):
    """Chapter outline for LOD2."""

    number: int = Field(description="Chapter number")
    title: str = Field(description="Chapter title")
    summary: str = Field(description="Chapter summary")
    key_events: List[str] = Field(default_factory=list, description="Key events in chapter")
    characters: List[str] = Field(default_factory=list, description="Characters in chapter")
    location: Optional[str] = Field(None, description="Primary location")
    word_count_target: int = Field(3000, description="Target word count")
    notes: Optional[str] = Field(None, description="Additional notes")

    # Fields that are generated by prompts but were missing from model
    pov: Optional[str] = Field(None, description="Point of view character")
    act: Optional[str] = Field(None, description="Act (I, II, or III)")
    character_developments: List[str] = Field(default_factory=list, description="Character development beats")

    # New fields for richer chapter outlines matching professional standards
    relationship_beats: List[str] = Field(default_factory=list, description="How relationships change in this chapter")
    tension_points: List[str] = Field(default_factory=list, description="What raises stakes or creates urgency")
    sensory_details: List[str] = Field(default_factory=list, description="Key sensory/atmospheric elements")
    subplot_threads: List[str] = Field(default_factory=list, description="Subplot progressions in this chapter")

    @classmethod
    def from_api_response(cls, data: Dict[str, Any]) -> "ChapterOutline":
        """Create ChapterOutline from API response, handling missing/extra fields gracefully."""
        # Extract only the fields that exist in the model
        model_fields = cls.model_fields.keys()
        filtered_data = {k: v for k, v in data.items() if k in model_fields}

        # Ensure required fields are present
        required_fields = ['number', 'title', 'summary']
        for field in required_fields:
            if field not in filtered_data:
                raise ValueError(f"Required field '{field}' missing from chapter data")

        # Clean up key_events field - handle mixed formats (string vs dict)
        # LLM sometimes returns structured scenes format instead of simple strings
        if 'key_events' in filtered_data:
            cleaned_events = []
            for event in filtered_data['key_events']:
                if isinstance(event, str):
                    cleaned_events.append(event)
                elif isinstance(event, dict):
                    # Extract string representation from dict (scenes format)
                    # Prefer 'scene' field, fallback to first string value found
                    if 'scene' in event:
                        cleaned_events.append(event['scene'])
                    elif 'note' in event:
                        cleaned_events.append(event['note'])
                    else:
                        # Fallback: use first string value found in dict
                        for v in event.values():
                            if isinstance(v, str):
                                cleaned_events.append(v)
                                break
            filtered_data['key_events'] = cleaned_events

        return cls(**filtered_data)


class Chapter(BaseModel):
    """Full chapter with prose content."""

    number: int = Field(description="Chapter number")
    title: str = Field(description="Chapter title")
    content: str = Field(description="Chapter prose content")
    word_count: int = Field(0, description="Actual word count")
    outline: Optional[ChapterOutline] = Field(None, description="Original outline")
    revision: int = Field(1, description="Revision number")
    git_sha: Optional[str] = Field(None, description="Git commit SHA for this version")


class Story(BaseModel):
    """Complete story structure."""

    # LOD3: High-level premise
    premise: Optional[str] = Field(None, description="Story premise (LOD3)")

    # LOD2: Treatment and outlines
    treatment: Optional[str] = Field(None, description="Story treatment (LOD2)")
    chapter_outlines: List[ChapterOutline] = Field(
        default_factory=list,
        description="Chapter outlines (LOD2)"
    )

    # LOD0: Full prose
    chapters: List[Chapter] = Field(
        default_factory=list,
        description="Full chapters with prose (LOD0)"
    )

    # Metadata
    genre: Optional[str] = Field(None, description="Story genre")
    themes: List[str] = Field(default_factory=list, description="Story themes")
    target_audience: Optional[str] = Field(None, description="Target audience")
    tone: Optional[str] = Field(None, description="Story tone")
    style: Optional[str] = Field(None, description="Writing style")

    @property
    def total_word_count(self) -> int:
        """Calculate total word count."""
        return sum(chapter.word_count for chapter in self.chapters)

    @property
    def is_complete(self) -> bool:
        """Check if all chapters have been written."""
        if not self.chapter_outlines:
            return False
        return len(self.chapters) == len(self.chapter_outlines)

    def get_chapter(self, number: int) -> Optional[Chapter]:
        """Get chapter by number."""
        for chapter in self.chapters:
            if chapter.number == number:
                return chapter
        return None

    def get_chapter_outline(self, number: int) -> Optional[ChapterOutline]:
        """Get chapter outline by number."""
        for outline in self.chapter_outlines:
            if outline.number == number:
                return outline
        return None

    def add_chapter(self, chapter: Chapter):
        """Add or update a chapter."""
        # Remove existing chapter with same number
        self.chapters = [c for c in self.chapters if c.number != chapter.number]
        # Add new chapter and sort
        self.chapters.append(chapter)
        self.chapters.sort(key=lambda c: c.number)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return self.model_dump(exclude_none=True)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Story":
        """Create from dictionary."""
        return cls(**data)


class StoryAnalysis(BaseModel):
    """Analysis results for a story."""

    analysis_type: str = Field(description="Type of analysis")
    content: str = Field(description="Analysis content in markdown")
    score: Optional[float] = Field(None, description="Score if applicable (0-100)")
    issues: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="List of identified issues"
    )
    suggestions: List[str] = Field(
        default_factory=list,
        description="Improvement suggestions"
    )
    git_sha: Optional[str] = Field(None, description="Git SHA of analyzed version")
    timestamp: Optional[str] = Field(None, description="Analysis timestamp")